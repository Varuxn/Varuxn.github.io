{
    "version": "https://jsonfeed.org/version/1",
    "title": "Varuxn",
    "subtitle": "目が離せません",
    "icon": "http://varuxn.github.io/assets/favicon.ico",
    "description": "Love and Freedom",
    "home_page_url": "http://Varuxn.github.io",
    "items": [
        {
            "id": "http://varuxn.github.io/2024/12/21/VMware-WSL/",
            "url": "http://varuxn.github.io/2024/12/21/VMware-WSL/",
            "title": "关于 VMware 与 WSL 在 Win11 虚拟化的一些问题",
            "date_published": "2024-12-21T12:47:19.650Z",
            "content_html": "<h1 id=\"关于-VMware-与-WSL-在-Win11-虚拟化的一些问题\"><a href=\"#关于-VMware-与-WSL-在-Win11-虚拟化的一些问题\" class=\"headerlink\" title=\"关于 VMware 与 WSL 在 Win11 虚拟化的一些问题\"></a>关于 VMware 与 WSL 在 Win11 虚拟化的一些问题</h1><h2 id=\"VMware-虚拟化问题\"><a href=\"#VMware-虚拟化问题\" class=\"headerlink\" title=\"VMware 虚拟化问题\"></a>VMware 虚拟化问题</h2><p>之前用虚拟机做计网 GNS3 组网实验的时候需要用到虚拟机虚拟化，然后一直显示虚拟化不成功，检查过 BIOS 等设置均显示没有错误。</p>\n<p>后来发现是 Windows 自带的虚拟机功能与 VMware 的虚拟化功能产生了冲突，处理办法如下：</p>\n<p>有关 Intel-VX 的问题，首先是在 BIOS 里打开相关选项</p>\n<p>然后 VMware 中也需要在设置里面开启</p>\n<p>接下来就是关闭 Windows 自带的虚拟机功能 <strong>控制面板-&gt;程序-&gt;启用或关闭Windows功能</strong></p>\n<p>Hyper-V和Windows虚拟机监控程序平台取消勾选</p>\n<p>如果找不到Hyper-V则管理员身份打开powershell输入命令<code>bcdedit /set hypervisorlaunchtype off</code></p>\n<p>最后重启电脑。</p>\n<p>参照博客：<a href=\"https://blog.csdn.net/m0_53022813/article/details/136936036\">https://blog.csdn.net/m0_53022813/article/details/136936036</a></p>\n<h2 id=\"WSL-虚拟化问题\"><a href=\"#WSL-虚拟化问题\" class=\"headerlink\" title=\"WSL 虚拟化问题\"></a>WSL 虚拟化问题</h2><p>在 VMware 虚拟化问题前，配置过一次 ubuntu 的 WSL 运行起来也没问题，后来因为一些原因卸载了。</p>\n<p>现在重新下回来的时候发现竟然又碰到了虚拟化的问题，然后就发现大概是上述 VMware 虚拟化关闭了本机一些虚拟化功能的问题。</p>\n<p>解决办法如下：</p>\n<p>打开 Windows 自带的虚拟机功能 <strong>控制面板-&gt;程序-&gt;启用或关闭Windows功能</strong></p>\n<p>Hyper-V和Windows虚拟机监控程序平台勾选</p>\n<p>如果找不到Hyper-V则管理员身份打开powershell输入命令<code>bcdedit /set hypervisorlaunchtype auto</code></p>\n<p>最后重启电脑。</p>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>我的是华硕天选4的笔记本，不知道其他的电脑会不会出现类似的问题。。。</p>\n",
            "tags": []
        },
        {
            "id": "http://varuxn.github.io/2024/12/21/Visual%20Studio%20C++%20%E6%B1%87%E7%BC%96%20%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/",
            "url": "http://varuxn.github.io/2024/12/21/Visual%20Studio%20C++%20%E6%B1%87%E7%BC%96%20%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/",
            "title": "Visual Studio C++ 汇编 混合编程",
            "date_published": "2024-12-21T12:46:38.153Z",
            "content_html": "<h1 id=\"Visual-Studio-C-汇编-混合编程\"><a href=\"#Visual-Studio-C-汇编-混合编程\" class=\"headerlink\" title=\"Visual Studio C++ 汇编 混合编程\"></a>Visual Studio C++ 汇编 混合编程</h1><h2 id=\"实验要求\"><a href=\"#实验要求\" class=\"headerlink\" title=\"实验要求\"></a>实验要求</h2><p>请用汇编语言编写实现GCD递推公式的子程序，对入口和出口参数形式不做要求，但需要用 C 语言函数来获取输入、调用汇编递推子程序，并且用 C 语言显示子程序返回的结果。</p>\n<h2 id=\"Visual-Studio-2020-下载\"><a href=\"#Visual-Studio-2020-下载\" class=\"headerlink\" title=\"Visual Studio 2020 下载\"></a>Visual Studio 2020 下载</h2><p>下载时勾选C++桌面开发选项。</p>\n<p><img loading=\"lazy\" data-src=\"https://images.cnblogs.com/cnblogs_com/Varuxn/2017186/o_241219131722_1.png\"></p>\n<h2 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h2><p>选择 <strong>文件-&gt;新建-&gt;项目</strong> ，语言选择 <strong>C++</strong> ，选择 <strong>空项目</strong> 。</p>\n<p><img loading=\"lazy\" data-src=\"https://images.cnblogs.com/cnblogs_com/Varuxn/2017186/o_241219132228_2.png\"></p>\n<p>修改环境配置为 <strong>x86</strong>。</p>\n<p><img loading=\"lazy\" data-src=\"https://images.cnblogs.com/cnblogs_com/Varuxn/2017186/o_241219133753_6.png\"></p>\n<p>在项目中新建 <code>gcd.asm</code> 和 <code>t.cpp</code> 或将这两个文件添加到项目中。</p>\n<p>右键项目，选择 <strong>生成依赖项-&gt;生成自定义</strong>，勾选 <strong>masm</strong> 选项。</p>\n<p><img loading=\"lazy\" data-src=\"https://images.cnblogs.com/cnblogs_com/Varuxn/2017186/o_241219132933_3.png\"></p>\n<p><img loading=\"lazy\" data-src=\"https://images.cnblogs.com/cnblogs_com/Varuxn/2017186/o_241219133303_4.png\"></p>\n<p>右键 <code>gcd.asm</code> 文件，选择 <strong>属性</strong>。</p>\n<p><strong>从生成中排除</strong> 选择 <strong>否</strong>。</p>\n<p><strong>项类型</strong> 选择 <strong>Microsoft Macro Assembler</strong>。</p>\n<p><img loading=\"lazy\" data-src=\"https://images.cnblogs.com/cnblogs_com/Varuxn/2017186/o_241219133637_5.png\"></p>\n<p>在编译运行的时候出现如下错误:</p>\n<p><code>scanf‘: This function or variable may be unsafe.Consider using scanf_s instead</code></p>\n<p>相关问题的解答 <a href=\"https://blog.csdn.net/p3145417646/article/details/131686176\">Link</a></p>\n<p>可以在 <code>.cpp</code> 文件的头文件加入 <code>#define _CRT_SECURE_NO_WARNINGS</code> 。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><p>cpp 文件</p>\n<pre><code class=\"cpp\">#define _CRT_SECURE_NO_WARNINGS\n#include &lt;stdio.h&gt;\n\n// 声明外部汇编函数\nextern &quot;C&quot; int GCD(int a, int b);\n\nint main() &#123;\n    int a, b, result;\n\n    // 获取用户输入\n    printf(&quot;请输入两个整数以计算其最大公约数：&quot;);\n    scanf(&quot;%d %d&quot;, &amp;a, &amp;b);\n\n    // 调用汇编函数\n    result = GCD(a, b);\n\n    // 输出结果\n    printf(&quot;数字 %d 和 %d 的最大公约数是：%d\\n&quot;, a, b, result);\n\n    return 0;\n&#125;\n</code></pre>\n<p>asm文件</p>\n<pre><code class=\"asm\">.model flat, c\n.code\npublic GCD       ; 声明函数为公共，可以被外部调用\n\nGCD proc\n    mov eax, [esp+4] ; 获取第一个参数 a (位于 esp+4)\n    mov ebx, [esp+8] ; 获取第二个参数 b (位于 esp+8)\n\ngcd_loop:\n    cmp ebx, 0       ; 如果 b == 0，跳转到结束\n    je gcd_done\n    xor edx, edx     ; 清空 edx，避免余数计算时的干扰\n    div ebx          ; eax = eax / ebx，余数存入 edx\n    mov eax, ebx     ; a = b\n    mov ebx, edx     ; b = a % b\n    jmp gcd_loop\n\ngcd_done:\n    ret              ; 返回结果存于 eax\nGCD endp\n\nend\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://varuxn.github.io/2024/12/21/TFTP-Server/",
            "url": "http://varuxn.github.io/2024/12/21/TFTP-Server/",
            "title": "HUST 计网 TFTP Server 实验总结",
            "date_published": "2024-12-21T12:45:40.177Z",
            "content_html": "<h1 id=\"TFTP-Server-总结\"><a href=\"#TFTP-Server-总结\" class=\"headerlink\" title=\"TFTP Server 总结\"></a>TFTP Server 总结</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>其实我菜的要死，然后在各位大佬的帮助下勉强完成了任务，然后过来水一篇博客，算是记录一下，也可以看作是蹭流量哈哈哈哈，可能主要讲一讲配置的问题。</p>\n<h2 id=\"前置环境\"><a href=\"#前置环境\" class=\"headerlink\" title=\"前置环境\"></a>前置环境</h2><p>也就是两个软件,Tftpd64 和 clumsy 以及在Windows环境下的编译问题。</p>\n<p><img loading=\"lazy\" data-src=\"https://images.cnblogs.com/cnblogs_com/Varuxn/2401763/o_241117145120_QQ20241117-225039.png\"></p>\n<h3 id=\"Tftpd64\"><a href=\"#Tftpd64\" class=\"headerlink\" title=\"Tftpd64\"></a>Tftpd64</h3><p>Tftpd64 的功能是当做TFTP通信中的客户端，各个参数的含义如下</p>\n<pre><code class=\"txt\">Host 127.0.0.1 即为本机地址\nPort 69 一般是69，如果端口冲突也可以选择其他的，需要与服务器的 port 一致\nLocal File 选择的是想要从客户端传送到服务器的文件的地址，从服务器传过来的文件也会放在同一目录下。\nRemote File 则是想要请求的文件的名称\nBlock Size 512 与实验要求的一致\nGet 就是从服务器索要文件\nPut 就是将文件传送给服务器\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"https://images.cnblogs.com/cnblogs_com/Varuxn/2401763/o_241117145302_tftp.png\"></p>\n<h3 id=\"clumsy\"><a href=\"#clumsy\" class=\"headerlink\" title=\"clumsy\"></a>clumsy</h3><p>clumsy 则是模拟传输过程的错误的软件。</p>\n<p>值得的一提的是，在调试代码的时候一直开着这个软件的丢包，导致我开着VPN却用不了GPT，甚至使用Baidu&#x2F;Google都困难。用网易云听歌也是有电流声，一开始还怀疑是耳机的问题哈哈哈。</p>\n<p>各个参数在文档中已经声明了</p>\n<pre><code class=\"txt\">\n延迟(Lag)，把数据包缓存一段时间后再发出，这样能够模拟网络延迟的状况。\n掉包(Drop)，随机丢弃一些数据。\n节流(Throttle)，把一小段时间内的数据拦截下来后再在之后的同一时间一同发出去。\n重发(Duplicate)，随机复制一些数据并与其本身一同发送。\n乱序(Out of order)，打乱数据包发送的顺序。\n篡改(Tamper)，随机修改小部分的包裹内容。\n</code></pre>\n<p>运行起来大概是下图这个样子，测试的时候用哪个就把哪个勾上然后start就可以了</p>\n<p><img loading=\"lazy\" data-src=\"https://images.cnblogs.com/cnblogs_com/Varuxn/2401763/o_241117150143_QQ20241117-230131.png\"></p>\n<h3 id=\"编译问题\"><a href=\"#编译问题\" class=\"headerlink\" title=\"编译问题\"></a>编译问题</h3><p>老师应该是下发一个 client 的 .c 文件的，但是大家会发现无法运行，因为老师下发的软件是需要在 linux 环境下运行。如果想要在 Win11 环境下运行需要更改一些头文件，然后代码里有些东西需要修改，这些内容不太重要，不如直接在下文讨论在写 Server 文件时该注意什么。</p>\n<h2 id=\"代码书写\"><a href=\"#代码书写\" class=\"headerlink\" title=\"代码书写\"></a>代码书写</h2><p>首先需要声明我的代码的文件是写到了 <code>t.cpp</code> 当中，编译的话使用的命令是 <code>g++ t.cpp -o tftp_server -lws2_32</code> ，会生成一个 <code>tftp_server.exe</code> 文件，直接运行就可以得到客户端，很遗憾本人菜菜没有做可视化界面&#x2F;kel。</p>\n<p>代码的书写参照了 <a href=\"https://doraemonqwq.cn/2024/10/07/2024-10-7-network/\">灰灰的博客</a>，并且对某些部分做了自己的一些修改。</p>\n<h3 id=\"一些定义以及调用\"><a href=\"#一些定义以及调用\" class=\"headerlink\" title=\"一些定义以及调用\"></a>一些定义以及调用</h3><p>一些用到的库，还有一些常量的声明，格外需要注意<code>#pragma comment(lib, &quot;ws2_32.lib&quot;)</code>命令，这个命令在 Windows 中是必须的，其中IP写成自己主机的IP。</p>\n<pre><code class=\"cpp\">#include &lt;WinSock2.h&gt;\n#include &lt;cstdio&gt;\n#include &lt;psdk_inc/_ip_types.h&gt;\n#include &lt;psdk_inc/_socket_types.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;wingdi.h&gt;\n#include &lt;winsock2.h&gt;\n#include &lt;ws2tcpip.h&gt;\n#include &lt;windows.h&gt;\n#include &lt;bits/stdc++.h&gt;\n\n#pragma comment(lib, &quot;ws2_32.lib&quot;)\n\n#define BUF_SIZE 516\n#define DATA_SIZE 512\n#define OPCODE_RRQ 1\n#define OPCODE_WRQ 2\n#define OPCODE_DATA 3\n#define OPCODE_ACK 4\n#define OPCODE_ERROR 5\n#define MAX_RETRIES 10\n#define TIMEOUT 5\n\nstatic const char *tftp_error_msg[] = &#123;\n    &quot;Undefined error&quot;,\n    &quot;File not found&quot;,\n    &quot;Access violation&quot;,\n    &quot;Disk full or allocation error&quot;,\n    &quot;Illegal TFTP operation&quot;,\n    &quot;Unknown transfer ID&quot;,\n    &quot;File already exists&quot;,\n    &quot;No such user&quot;\n&#125;;\nconst char IP[30]=&quot;&quot;;\nconst int PORT=6699;\n</code></pre>\n<h3 id=\"TFTP的初始化\"><a href=\"#TFTP的初始化\" class=\"headerlink\" title=\"TFTP的初始化\"></a>TFTP的初始化</h3><p>下面这段代码也是 Windows 环境下不同于 Linux 的部分。</p>\n<pre><code class=\"cpp\">int TFTP_init()\n&#123;\n    WSADATA wsaData;\n    int result = WSAStartup(MAKEWORD(2, 2), &amp;wsaData); // 初始化 Winsock\n    if (result != 0) &#123;\n        cerr&lt;&lt;&quot;WSAStartup failed: &quot;&lt;&lt;result&lt;&lt;endl;\n        return 1;\n    &#125;\n    printf(&quot;Winsock initialized.\\n&quot;);\n    return 0;\n&#125;\n</code></pre>\n<p>然后就是根据服务器的地址和接口绑定套接字（这段内容在代码的 Server 类的 init 部分），然后就是不断循环接收来自客户端的请求（Server 类的 work 部分）。</p>\n<p>TFTP_Solve 类则是对于客户端的每个请求进行分类处理，而 ERRORthings 则是对错误信息进行处理后发送给客户端。接下来重点介绍 RRQ 和 WRQ 类。</p>\n<p>由于实验有个要求是需要记录传输数据的速度，为此设计了一个 <code>gettimeofday</code> 函数用来记录每次传输的起始和截止时间用于计算速度。</p>\n<h3 id=\"RRQ\"><a href=\"#RRQ\" class=\"headerlink\" title=\"RRQ\"></a>RRQ</h3><p>首先需要知道的是，我们将一个文件分成了若干块，每块的大小是 512bytes ，不断循环读取文件直到读入的字符数小于 512 。</p>\n<p>先将操作码和块的编号写到首部</p>\n<pre><code class=\"cpp\">memset(data_pac, 0, BUF_SIZE);\n*(unsigned short*)data_pac = htons(OPCODE_DATA);  // 操作码：数据包\n*(unsigned short*)(data_pac + 2) = htons(block);\n</code></pre>\n<p>然后开始读入文件中的信息，并且处理错误信息，接下来就是传输，只要没有收到确认包或者说重传的次数小于我们要求的最大重传次数时则重传。<code>while(!ack&amp;&amp;tot_retry&lt;MAX_RETRIES)</code></p>\n<p>使用 sendto 函数发送当前块到客户端</p>\n<pre><code class=\"cpp\">sendto(socketfd, data_pac, bytes_read + 4, 0, (sockaddr*)&amp;client_addr, client_addr_len);\n</code></pre>\n<p>然后使用 select 函数检测</p>\n<pre><code class=\"cpp\">int select_result = select(socketfd + 1, &amp;read_fds, NULL, NULL, &amp;tv);\n</code></pre>\n<p>检查是否传输的数据有差错，并对错误类型进行分类处理决定是否重传和返回怎样的错误信息。如果 select 函数没有发现错误则使用 recvfrom 函数接收来自客户端的ACK包并进行检查判断。</p>\n<pre><code class=\"cpp\">recv_len=recvfrom(socketfd,buf,BUF_SIZE,0,(sockaddr*)&amp;client_addr,&amp;client_addr_len);\n</code></pre>\n<p>最后计算传输速率即可。</p>\n<h3 id=\"WRQ\"><a href=\"#WRQ\" class=\"headerlink\" title=\"WRQ\"></a>WRQ</h3><p>虽然是师从灰灰，但是也对一部分进行了修改和优化，也就是 WRQ 这一部分。灰灰的代码在这一部分，面对丢包和篡改的情况往往会发生服务器不断读取来自客户端的同一个 block 的数据，陷入死循环，一直将客户端某个 block 的数据写入目的文件。在调试后发现问题出现在 Server 在把选择新的块的时候并没有考虑客户端是否收到了 ACK 并且向下一个 block 移动，而是仅仅将 block++，对相关部分我们需要做出修改。</p>\n<p>依旧是在确定文件的指针无误后进入循环，一块块地接收数据，先将上一个包的 ACK 发送给客户端，然后接受数据包。</p>\n<p>在此处我们设置两个变量 <code>received_block</code> 和 <code>expected_block</code>，分别表示我们接受到的 block 编号和我们期望收到的 block 编号。如果两者一致的话则表明我们的数据传输没有任何问题，直接写入文件，并且期望下一个 block 。</p>\n<pre><code class=\"cpp\">if (received_block == expected_block) &#123;\n    printf(&quot;Received block NO.%hu\\n&quot;, received_block);\n    tot_recv += recv_len - 4;\n    fwrite(buf + 4, 1, recv_len - 4, file);  // 写入文件\n    expected_block++;  // 仅在收到正确的数据包时递增\n&#125;\n</code></pre>\n<p>否则的话输出错误提示信息并且尝试再次发送ACK包以及接受数据，直到收到的 block 编号和期望的一致。</p>\n<p>最后就是统计传输速率以及发送最后一个块的ACK给客户端。</p>\n<h2 id=\"code\"><a href=\"#code\" class=\"headerlink\" title=\"code\"></a>code</h2><p>本 blog 只讲述了一种最简单的实现方法（而且还没验收），需要代码详细解释的请移步灰灰的博客请教师祖大人捏。可视化的俺也没做，俺是菜狗。</p>\n<pre><code class=\"cpp\">//g++ t.cpp -o tftp_server -lws2_32\n#include &lt;WinSock2.h&gt;\n#include &lt;cstdio&gt;\n#include &lt;psdk_inc/_ip_types.h&gt;\n#include &lt;psdk_inc/_socket_types.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;wingdi.h&gt;\n#include &lt;winsock2.h&gt;\n#include &lt;ws2tcpip.h&gt;\n#include &lt;windows.h&gt;\n#include &lt;bits/stdc++.h&gt;\n\n#pragma comment(lib, &quot;ws2_32.lib&quot;)\n\n#define BUF_SIZE 516\n#define DATA_SIZE 512\n#define OPCODE_RRQ 1\n#define OPCODE_WRQ 2\n#define OPCODE_DATA 3\n#define OPCODE_ACK 4\n#define OPCODE_ERROR 5\n#define MAX_RETRIES 10\n#define TIMEOUT 5\n\nusing namespace std;\n\nstatic const char *tftp_error_msg[] = &#123;\n    &quot;Undefined error&quot;,\n    &quot;File not found&quot;,\n    &quot;Access violation&quot;,\n    &quot;Disk full or allocation error&quot;,\n    &quot;Illegal TFTP operation&quot;,\n    &quot;Unknown transfer ID&quot;,\n    &quot;File already exists&quot;,\n    &quot;No such user&quot;\n&#125;;\nconst char IP[30]=&quot;0.0.0.0&quot;;\nconst int PORT=6699;\nint client_addr_len;\n\nvoid record(char *ch)\n&#123;\n    FILE *file;\n    file=fopen(&quot;record_log&quot;,&quot;w&quot;);\n    fwrite(ch,1,strlen(ch),file);\n&#125;\n\nint gettimeofday(struct timeval* tp, struct timezone* tzp)\n&#123;\n    if (tp == nullptr) return -1;\n\n    struct _timeb timebuffer;\n    _ftime(&amp;timebuffer);\n\n    tp-&gt;tv_sec = static_cast&lt;long&gt;(timebuffer.time);      // 秒部分\n    tp-&gt;tv_usec = timebuffer.millitm * 1000;              // 将毫秒转换为微秒\n\n    return 0;\n&#125;\n\nstruct ERRORthings\n&#123;\n    short opcode;\n    short error_code;\n    char message[BUF_SIZE];\n    void init(short _error_code,const char* _message)\n    &#123;\n        opcode = 5; \n        error_code = _error_code;\n        strcpy(message+4, _message); \n    &#125;\n    void work(int socketfd, sockaddr_in &amp;client_addr)\n    &#123;\n        memset(message, 0, BUF_SIZE);\n        *(unsigned short*)message = htons(opcode);\n        *(unsigned short*)(message + 2) = htons(error_code);\n        int packet_length = 4 + strlen(message) + 1;\n        int send_len = sendto(socketfd, message, packet_length, 0, (sockaddr *)&amp;client_addr, client_addr_len);\n    &#125;\n&#125;;\n\nclass RRQ\n&#123;\n    public:\n    void work(const char *filename, const char *mode, int socketfd, struct sockaddr_in &amp;client_addr)\n    &#123;\n        FILE *file;\n        if(strcmp(mode,&quot;netascii&quot;)==0)\n            file=fopen(filename,&quot;r&quot;);\n        else file=fopen(filename,&quot;rb&quot;);\n        if(!file)\n        &#123;\n            cerr&lt;&lt;&quot;ERROR: Cannot open file for reading: &quot;&lt;&lt;filename&lt;&lt;endl;\n            ERRORthings packet;\n            packet.init(1,tftp_error_msg[1]);\n            packet.work(socketfd, client_addr);\n            return ;\n        &#125;\n        unsigned short block=1;\n        int bytes_read=0,tot_send=0;;\n        char buf[BUF_SIZE];\n        char data_pac[BUF_SIZE];\n        timeval start,end;\n        gettimeofday(&amp;start, NULL);\n        do\n        &#123;\n            memset(data_pac, 0, BUF_SIZE);\n            *(unsigned short*)data_pac = htons(OPCODE_DATA);  // 操作码：数据包\n            *(unsigned short*)(data_pac + 2) = htons(block);\n\n            bytes_read=fread(data_pac+4,1,DATA_SIZE,file);\n            int tot_retry=0;\n            bool ack=false;\n            if(bytes_read&lt;0)\n            &#123;\n                cerr&lt;&lt;&quot;ERROR: Reading file&quot;&lt;&lt;endl;\n                ERRORthings packet;\n                packet.init(0,&quot;Read error&quot;);\n                packet.work(socketfd,client_addr);\n                break;\n            &#125;\n            int recv_len;\n            while(!ack&amp;&amp;tot_retry&lt;MAX_RETRIES)\n            &#123;\n                sendto(socketfd, data_pac, bytes_read + 4, 0, (sockaddr*)&amp;client_addr, client_addr_len);\n                printf(&quot;sending NO.%hu packet&quot;, block);\n                // 超时重传\n                struct timeval tv;\n                tv.tv_sec=TIMEOUT;\n                tv.tv_usec=0;\n                fd_set read_fds;\n                FD_ZERO(&amp;read_fds);\n                FD_SET(socketfd, &amp;read_fds);\n                //传入ACK或超时\n                int select_result = select(socketfd + 1, &amp;read_fds, NULL, NULL, &amp;tv);\n                if(select_result&gt;0)\n                &#123;\n                    recv_len=recvfrom(socketfd,buf,BUF_SIZE,0,(sockaddr*)&amp;client_addr,&amp;client_addr_len);\n                    if(recv_len&gt;=4&amp;&amp;ntohs(*(unsigned short*)buf)==OPCODE_ACK&amp;&amp;ntohs(*(unsigned short*)(buf + 2))==block)\n                    &#123;\n                        printf(&quot;,recived NO.%hupacket\\n&quot;, block);\n                        ack=true;\n                    &#125;\n                    else\n                    &#123;\n                        printf(&quot;,ACK invalid,send NO.%hupacket again\\n&quot;, block);\n                        tot_retry++;\n                    &#125;\n                &#125;\n                else if(select_result==0)\n                &#123;\n                    printf(&quot;Timeout,retry sending NO.%hu packet\\n&quot;,block);\n                    tot_retry++;\n                &#125;\n                else\n                &#123;\n                    perror(&quot;select() error&quot;);\n                    fclose(file);\n                    return ;\n                &#125;\n            &#125;\n            tot_send+=bytes_read;\n            block++;\n        &#125;while(bytes_read==DATA_SIZE);\n        fclose(file);\n        gettimeofday(&amp;end, NULL);\n        double time_taken=(end.tv_sec-start.tv_sec)+(end.tv_usec-start.tv_usec)/1000000.0;\n        double throughput=tot_send/time_taken;\n        cerr&lt;&lt;&quot;Download throughput: &quot;&lt;&lt;throughput/1024&lt;&lt;&quot; KB/s&quot;&lt;&lt;endl;\n    &#125;\n&#125;;\n\nclass WRQ\n&#123;\n    public:\n    void work(const char *filename, const char *mode, int socketfd, struct sockaddr_in &amp;client_addr)\n    &#123;\n        FILE *file;\n        if(strcmp(mode,&quot;netascii&quot;)==0)\n            file=fopen(filename,&quot;w&quot;);\n        else file=fopen(filename,&quot;wb&quot;);\n        if(!file)\n        &#123;\n            cerr&lt;&lt;&quot;ERROR: Cannot open file for writing: &quot;&lt;&lt;filename&lt;&lt;endl;\n            ERRORthings error_packet;\n            error_packet.init(2,tftp_error_msg[2]);\n            error_packet.work(socketfd, client_addr);\n            return ;\n        &#125;\n        int tot_recv=0,recv_len;\n        unsigned short block=0;\n        struct timeval start,end;\n        char buf[BUF_SIZE];\n        gettimeofday(&amp;start, NULL);\n        unsigned short expected_block = 1;  // TFTP WRQ开始时，第一个数据包的block是1\n        do &#123;\n            memset(buf, 0, BUF_SIZE);\n\n            // 发送ACK包\n            *(unsigned short *)buf = htons(OPCODE_ACK);\n            *(unsigned short *)(buf + 2) = htons(expected_block - 1);  // ACK上一块的block\n            if (sendto(socketfd, buf, 4, 0, (sockaddr *)&amp;client_addr, client_addr_len) &lt; 0) &#123;\n                perror(&quot;sendto failed&quot;);\n                fclose(file);\n                return;\n            &#125;\n\n            // 接收数据包\n            recv_len = recvfrom(socketfd, buf, BUF_SIZE, 0, (sockaddr *)&amp;client_addr, &amp;client_addr_len);\n            if (recv_len &lt; 4 || ntohs(*(unsigned short *)buf) != OPCODE_DATA) &#123;\n                printf(&quot;The packet received is not a valid data packet\\n&quot;);\n                ERRORthings error_packet;\n                error_packet.init(4, tftp_error_msg[4]);\n                error_packet.work(socketfd, client_addr);\n                fclose(file);\n                return;\n            &#125;\n\n            // 获取接收数据包的block编号\n            unsigned short received_block = ntohs(*(unsigned short *)(buf + 2));\n\n            if (received_block == expected_block) &#123;\n                printf(&quot;Received block NO.%hu\\n&quot;, received_block);\n                tot_recv += recv_len - 4;\n                fwrite(buf + 4, 1, recv_len - 4, file);  // 写入文件\n                expected_block++;  // 仅在收到正确的数据包时递增\n            &#125; else &#123;\n                printf(&quot;Duplicate or out-of-order packet, expected block: %hu, received block: %hu\\n&quot;, expected_block, received_block);\n            &#125;\n        &#125; while (recv_len == DATA_SIZE + 4);\n         memset(buf,0,BUF_SIZE);\n        *(unsigned short*)buf = htons(OPCODE_ACK);\n        *(unsigned short*)(buf + 2) = htons(expected_block-1);\n        sendto(socketfd,buf,4,0,(sockaddr*)&amp;client_addr,client_addr_len);\n        fclose(file);\n        gettimeofday(&amp;end, NULL);\n        double time_taken=(end.tv_sec-start.tv_sec)+(end.tv_usec-start.tv_usec)/1000000.0;\n        double throughput=tot_recv/time_taken;\n        cerr&lt;&lt;&quot;Download throughput: &quot;&lt;&lt;throughput/1024&lt;&lt;&quot; KB/s&quot;&lt;&lt;endl;\n        fclose(file);\n    &#125;\n&#125;;\n\nclass TFTP_Solve\n&#123;\n    private:\n    int socketfd;\n    sockaddr_in client_addr;\n    char buf[BUF_SIZE];\n\n    public:\n    TFTP_Solve(int _socketfd,sockaddr_in &amp;_client_addr): socketfd(_socketfd),client_addr(_client_addr)&#123;&#125;\n    void Work_for_RRQ(const char *filname,const char *mode)\n    &#123;\n        RRQ RRQproject;\n        RRQproject.work(filname,mode,socketfd,client_addr);\n    &#125;\n    void Work_for_WRQ(const char *filname,const char *mode)\n    &#123;\n        WRQ WRQproject;\n        WRQproject.work(filname,mode,socketfd,client_addr);\n    &#125;\n    void work()\n    &#123;\n        int rev_len=recvfrom(socketfd,buf,BUF_SIZE,0,(sockaddr *)&amp;client_addr,&amp;client_addr_len);\n        if(rev_len&lt;4)\n        &#123;\n            cerr&lt;&lt;&quot;ERROR: Can&#39;t receive request&quot;&lt;&lt;endl;\n            ERRORthings packet;\n            packet.init(4,tftp_error_msg[4]);\n            packet.work(socketfd, client_addr);\n            return ;\n        &#125;\n        short opcode=ntohs(*(unsigned short *)buf);\n        char *filename=buf+2;\n        char *mode=filename+strlen(filename)+1;\n\n        if (strcmp(mode, &quot;netascii&quot;) != 0 &amp;&amp; strcmp(mode, &quot;octet&quot;) != 0)\n        &#123;\n            ERRORthings packet;\n            packet.init(4,&quot;Unsupported transfer mode.&quot;);\n            packet.work(socketfd, client_addr);\n            return ;\n        &#125;\n\n        if(opcode==OPCODE_RRQ) Work_for_RRQ(filename,mode);\n        else if(opcode==OPCODE_WRQ) Work_for_WRQ(filename,mode);\n        else if(opcode==OPCODE_ERROR);\n        else\n        &#123;\n            cerr&lt;&lt;&quot;ERROR: Unknown request&quot;&lt;&lt;endl;\n            ERRORthings packet;\n            packet.init(4,tftp_error_msg[4]);\n            packet.work(socketfd,client_addr);\n        &#125;\n    &#125;\n&#125;;\n\nclass Server\n&#123;\n    private:\n    int socketfd;\n    \n    public:\n    Server(): socketfd(-1)&#123;&#125;\n    sockaddr_in getAddr(const char *ip,int port)\n    &#123;\n        sockaddr_in addr;\n        addr.sin_family = AF_INET;\n        addr.sin_port = htons(port);\n        addr.sin_addr.S_un.S_addr = INADDR_ANY;\n        return addr;\n    &#125;\n    void init()\n    &#123;\n        socketfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);\n        if(socketfd&lt;0)\n        &#123;\n            cerr&lt;&lt;&quot;Error creating socket...&quot;&lt;&lt;endl;\n            exit(1);\n        &#125;\n        sockaddr_in server_addr = getAddr(IP, PORT);\n        if (bind(socketfd, (struct sockaddr *) &amp;server_addr, sizeof(server_addr)) &lt; 0) &#123;\n            cerr&lt;&lt;&quot;Bind local port failed!&quot;&lt;&lt;endl;\n            exit(1);\n        &#125;\n        cerr&lt;&lt;&quot;TFTP is successfully started on port &quot;&lt;&lt;PORT&lt;&lt;&quot; at IP address &quot;&lt;&lt;IP&lt;&lt;endl;\n    &#125;\n    void work()\n    &#123;\n        while(true)\n        &#123;\n            sockaddr_in client_addr; client_addr_len=sizeof(client_addr);\n            TFTP_Solve project(socketfd,client_addr);\n            project.work();\n        &#125;\n    &#125;\n    ~Server()&#123;if(socketfd!=-1) closesocket(socketfd);&#125;\n&#125;;\n\n\nint TFTP_init()\n&#123;\n    WSADATA wsaData;\n    int result = WSAStartup(MAKEWORD(2, 2), &amp;wsaData); // 初始化 Winsock\n    if (result != 0) &#123;\n        cerr&lt;&lt;&quot;WSAStartup failed: &quot;&lt;&lt;result&lt;&lt;endl;\n        return 1;\n    &#125;\n    printf(&quot;Winsock initialized.\\n&quot;);\n    return 0;\n&#125;\n\nint main()\n&#123;\n    TFTP_init();\n    Server S; S.init(); S.work();\n    return 0;\n&#125;\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://varuxn.github.io/2024/12/21/LateX/",
            "url": "http://varuxn.github.io/2024/12/21/LateX/",
            "title": "LateX",
            "date_published": "2024-12-21T12:42:53.204Z",
            "content_html": "<p>组合数： <code>$\\binom&#123;n&#125;&#123;m&#125;$</code> $\\binom{n}{m}$</p>\n<p>第一类斯特林数： <code>$n \\brack m$</code> $n \\brack m$</p>\n<p>第二类斯特林数： <code>$n \\brace m$</code> $n \\brace m$ 当然 <code>$\\&#123;_m^n\\&#125;$</code> ${_m^n}$ 也可以,<del>但是可能会丑一些</del></p>\n<p>分数： 小的 <code>$\\frac&#123;n&#125;&#123;m&#125;$</code> $\\frac{n}{m}$ 大的 <code>$\\dfrac&#123;n&#125;&#123;m&#125;$</code> $\\dfrac{n}{m}$</p>\n<p>大于等于： <code>$\\ge$</code> $\\ge$ , 小于等于： <code>$\\le$</code> $\\le$ , 不等于：<code>$\\neq$</code> $\\neq$</p>\n<p>连加： <code>$\\sum$</code> $\\sum$ , 连乘： <code>$\\prod$</code> $\\prod$</p>\n<p>上下标搞到正上或者正下方： 在后面加上 <code>$\\limits$</code></p>\n<p>整行公式可以： <code>$\\displaystyle$</code> 配合 <code>$$  $$</code> 使用效果更佳。</p>\n<p>点乘： <code>$\\cdot$</code> $\\cdot$ ， 叉乘： <code>$\\times$</code> $\\times$</p>\n<p>向上取整： <code>$\\lceil x \\rceil$</code> $\\lceil x \\rceil$ ， 向下取整： <code>$\\lfloor x \\rfloor$</code> $\\lfloor x \\rfloor$</p>\n<p>异或： <code>$\\otimes$</code> $\\otimes$ 或者 <code>$^&#123;\\wedge&#125;$</code> $^{\\wedge}$</p>\n<p>开方： <code>$\\sqrt[n]&#123;x&#125;$</code> $\\sqrt[n]{x}$</p>\n<p>属于： <code>$\\in$</code> $\\in$ ， 不属于： <code>$\\notin$</code> $\\notin$</p>\n<p>同余： <code>$\\equiv$</code> $\\equiv$ ， 不同余： <code>$\\not\\equiv$</code> $\\not\\equiv$</p>\n<p>整除： <code>$\\mid$</code> $\\mid$ ， 不整除： <code>$\\nmid$</code> $\\nmid$</p>\n<p>空格： 小 <code>$\\;$</code> $;$， 中 <code>$\\quad$</code> $\\quad$， 大 <code>$\\qquad$</code> $\\qquad$</p>\n<p>各种包含： <code>$\\subset$</code> $\\subset$ ， <code>$\\supset$</code> $\\supset$ ， <code>$\\subseteq$</code> $\\subseteq$ ， <code>$\\supseteq$</code>  $\\supseteq$</p>\n<p>让字符变大 <code>$\\big[$</code> $\\big[$ ， <code>$\\Big[$</code> $\\Big[$</p>\n<p>还有一堆花里呼哨的符号： <code>$\\phi$</code> $\\phi$ <code>$\\varphi$</code> $\\varphi$ <code>$\\Omega$</code> $\\Omega$ <code>$\\omega$</code> $\\omega$ <code>$\\infty$</code> $\\infty$</p>\n<p>部分内容来自 <a href=\"https://www.cnblogs.com/wxyww/p/latex.html\">https://www.cnblogs.com/wxyww/p/latex.html</a></p>\n",
            "tags": []
        }
    ]
}